"use strict";(self.webpackChunkgiza_mri=self.webpackChunkgiza_mri||[]).push([[787],{2326:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"concepts-and-theory/enhanced-gpc-algorithm","title":"The Enhanced GPC (EGPC) Algorithm","description":"While the base GPC algorithm provides a solid foundation, our framework evolves it into a hybrid, intelligent system. The rungpcformrisegmentation function in final.py is not just an implementation but an enhancement, incorporating advanced strategies to tackle the specific challenges of MRI segmentation, such as high dimensionality and the risk of premature convergence.","source":"@site/docs/3-concepts-and-theory/3-enhanced-gpc-algorithm.md","sourceDirName":"3-concepts-and-theory","slug":"/concepts-and-theory/enhanced-gpc-algorithm","permalink":"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/enhanced-gpc-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3-concepts-and-theory/3-enhanced-gpc-algorithm.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"The Enhanced GPC (EGPC) Algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Image Preprocessing Pipeline","permalink":"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/image-preprocessing-pipeline"},"next":{"title":"Smart Post-processing","permalink":"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/smart-post-processing"}}');var o=i(4848),a=i(8453);const r={sidebar_position:3,title:"The Enhanced GPC (EGPC) Algorithm"},s="The Enhanced GPC (EGPC) Algorithm",c={},l=[{value:"1. Hybrid Multi-Strategy Initialization",id:"1-hybrid-multi-strategy-initialization",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"the-enhanced-gpc-egpc-algorithm",children:"The Enhanced GPC (EGPC) Algorithm"})}),"\n",(0,o.jsx)(n.admonition,{title:"From Standard to a Hybrid Intelligent System",type:"tip",children:(0,o.jsxs)(n.p,{children:["While the ",(0,o.jsx)(n.a,{href:"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/base-gpc-algorithm",children:"base GPC algorithm"})," provides a solid foundation, our framework evolves it into a hybrid, intelligent system. The ",(0,o.jsx)(n.code,{children:"run_gpc_for_mri_segmentation"})," function in ",(0,o.jsx)(n.code,{children:"final.py"})," is not just an implementation but an enhancement, incorporating advanced strategies to tackle the specific challenges of MRI segmentation, such as high dimensionality and the risk of premature convergence."]})}),"\n",(0,o.jsx)(n.p,{children:"The key innovations that transform the standard GPC into our Enhanced GPC (EGPC) are detailed below."}),"\n",(0,o.jsx)(n.h2,{id:"1-hybrid-multi-strategy-initialization",children:"1. Hybrid Multi-Strategy Initialization"}),"\n",(0,o.jsxs)(n.p,{children:["The performance of any population-based algorithm is highly sensitive to its initial population. A diverse set of starting solutions significantly increases the chance of finding the global optimum. Instead of relying on purely random initialization, EGPC employs a sophisticated ",(0,o.jsx)(n.strong,{children:"hybrid initialization"})," approach. The population (",(0,o.jsx)(n.code,{children:"npop"}),") is divided into three groups, each initialized with a different strategy to ensure maximum initial diversity:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Random Strategy:"})," A portion of the population is initialized randomly across the entire search space to ensure baseline stochastic coverage."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Max-Distance (K-Means++ inspired) Strategy:"})," To prevent initial solutions from clustering together, this strategy places new agents as far as possible from already initialized ones, ensuring a well-dispersed population."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Quantile-based Strategy:"})," Another portion is initialized with values from different intensity quantiles of the image. This guarantees that initial cluster centers are spread across the full spectrum of pixel intensities, from dark to bright."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"// Hybrid Initialization Logic from final.py\r\nfor i in range(gpc_params.npop):\r\n    if i < gpc_params.npop // 3:\r\n        # 1. Random Initialization\r\n        population[i].position = ...\r\n    elif i < 2 * gpc_params.npop // 3:\r\n        # 2. Max-Distance (K-Means++ inspired) Initialization\r\n        population[i].position = ...\r\n    else:\r\n        # 3. Quantile-based Initialization\r\n        population[i].position = ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);