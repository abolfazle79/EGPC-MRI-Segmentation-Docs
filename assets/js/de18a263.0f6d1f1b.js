"use strict";(self.webpackChunkgiza_mri=self.webpackChunkgiza_mri||[]).push([[365],{4844:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"code-reference/function-postprocess","title":"Function: postprocess_tumor_segmentation","description":"This function is the final, critical stage of the segmentation pipeline. Its purpose is to take the raw, noisy segmentation map from the GPC algorithm and apply a series of aggressive, heuristic-based filters. The goal is to eliminate false positives, remove artifacts, and produce a clean, anatomically plausible final tumor mask.","source":"@site/docs/4-code-reference/4-function-postprocess.md","sourceDirName":"4-code-reference","slug":"/code-reference/function-postprocess","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-postprocess","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/4-code-reference/4-function-postprocess.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Function: postprocess_tumor_segmentation"},"sidebar":"tutorialSidebar","previous":{"title":"Function: run_gpc_for_mri_segmentation","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-gpc-segmentation"},"next":{"title":"Results & Evaluation","permalink":"/EGPC-MRI-Segmentation-Docs/docs/category/results--evaluation"}}');var s=i(4848),r=i(8453);const o={sidebar_position:4,title:"Function: postprocess_tumor_segmentation"},a="Function: postprocess_tumor_segmentation",l={},c=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Values",id:"return-values",level:2},{value:"Core Logic and Filtering Pipeline",id:"core-logic-and-filtering-pipeline",level:2},{value:"Stage 1: Initial Mask Generation",id:"stage-1-initial-mask-generation",level:3},{value:"Stage 2: Aggressive Artifact Filtering",id:"stage-2-aggressive-artifact-filtering",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsxs)(n.h1,{id:"function-postprocess_tumor_segmentation",children:["Function: ",(0,s.jsx)(n.code,{children:"postprocess_tumor_segmentation"})]})}),"\n",(0,s.jsx)(n.admonition,{title:"From Raw Clusters to a Refined Mask",type:"info",children:(0,s.jsx)(n.p,{children:"This function is the final, critical stage of the segmentation pipeline. Its purpose is to take the raw, noisy segmentation map from the GPC algorithm and apply a series of aggressive, heuristic-based filters. The goal is to eliminate false positives, remove artifacts, and produce a clean, anatomically plausible final tumor mask."})}),"\n",(0,s.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def postprocess_tumor_segmentation(labels, centroids, image_shape, brain_mask, preprocessed_image):\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"labels"})})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): A 1D NumPy array containing the raw cluster assignments for each brain pixel, as returned by the GPC function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"centroids"})})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): A 1D NumPy array containing the final, optimal intensity values for each cluster's center."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"image_shape"})})," (",(0,s.jsx)(n.code,{children:"tuple"}),"): The dimensions (height, width) of the original image, used to reconstruct the full-size mask."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"brain_mask"})})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The 2D binary (boolean) mask of the brain region, used for distance calculations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"preprocessed_image"})})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The 2D preprocessed grayscale image, used for intensity-based filtering."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"return-values",children:"Return Values"}),"\n",(0,s.jsx)(n.p,{children:"The function returns a tuple containing two elements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"tumor_mask"})})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The final, cleaned, 2D binary (boolean) mask representing the detected tumor region."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"tumor_cluster_id"})})," (",(0,s.jsx)(n.code,{children:"int"}),"): The integer index of the cluster that was identified as the primary tumor candidate (the one with the highest intensity)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-logic-and-filtering-pipeline",children:"Core Logic and Filtering Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"The function executes a sequential pipeline of aggressive filters to refine the initial raw mask."}),"\n",(0,s.jsx)(n.h3,{id:"stage-1-initial-mask-generation",children:"Stage 1: Initial Mask Generation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The function first identifies the tumor candidate cluster by finding the cluster with the highest intensity centroid (",(0,s.jsx)(n.code,{children:"np.argmax(centroids)"}),"), as tumors typically appear hyperintense."]}),"\n",(0,s.jsxs)(n.li,{children:["It then reconstructs the initial binary ",(0,s.jsx)(n.code,{children:"tumor_mask"})," by selecting all brain pixels that were assigned to this cluster."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"stage-2-aggressive-artifact-filtering",children:"Stage 2: Aggressive Artifact Filtering"}),"\n",(0,s.jsx)(n.p,{children:"This stage applies a series of non-adaptive, strong filters to clean the mask."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edge Zone Filtering:"})," An ",(0,s.jsx)(n.code,{children:"interior_mask"})," is created by calculating the distance of each pixel from the brain's edge (",(0,s.jsx)(n.code,{children:"ndimage.distance_transform_edt"}),'). Any part of the detected tumor that falls within a 15-pixel-wide "edge zone" is aggressively removed. This is highly effective at eliminating skull-edge artifacts.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Size Filtering:"})," ",(0,s.jsx)(n.code,{children:"morphology.remove_small_objects"})," is used with a high threshold (200 pixels) to eliminate any small, noisy detections that are unlikely to be clinically relevant."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strong Morphological Opening:"})," A large opening kernel (",(0,s.jsx)(n.code,{children:"morphology.disk(4)"}),") is applied to sever any thin, spurious connections between regions and to smooth the shape of the remaining candidates."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hole Filling:"})," ",(0,s.jsx)(n.code,{children:"morphology.binary_closing"})," is used to fill any small, internal holes within the candidate tumor regions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Intensity-based Filtering:"})," A strong intensity filter is applied. It calculates the intensity distribution of the remaining candidate pixels and removes the bottom 30% (",(0,s.jsx)(n.code,{children:"np.percentile(..., 30)"}),"), effectively keeping only the brightest core of the detected regions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dominant Component Selection:"})," Finally, if multiple disconnected tumor regions remain after filtering, the function checks their relative sizes. If one component is significantly larger (at least 3 times) than the next largest, it is assumed to be the main tumor mass, and all other smaller components are discarded."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This aggressive pipeline ensures that the final ",(0,s.jsx)(n.code,{children:"tumor_mask"})," is very clean, though it carries the risk of being overly conservative and removing parts of the true tumor, which is the trade-off for high precision."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);