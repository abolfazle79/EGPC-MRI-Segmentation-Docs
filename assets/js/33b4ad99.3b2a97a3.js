"use strict";(self.webpackChunkgiza_mri=self.webpackChunkgiza_mri||[]).push([[186],{3051:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts-and-theory/smart-post-processing","title":"Smart Post-processing","description":"The output of the EGPC algorithm is a raw segmentation mask where pixels are assigned to different clusters. However, this raw mask may still contain noise, small artifacts, or non-tumor regions that were incorrectly clustered. The smartpostprocesstumor_segmentation function is a crucial final step that applies a series of intelligent and adaptive filters to refine this mask and produce a clinically plausible result.","source":"@site/docs/3-concepts-and-theory/4-smart-post-processing.md","sourceDirName":"3-concepts-and-theory","slug":"/concepts-and-theory/smart-post-processing","permalink":"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/smart-post-processing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3-concepts-and-theory/4-smart-post-processing.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Smart Post-processing"},"sidebar":"tutorialSidebar","previous":{"title":"The Enhanced GPC (EGPC) Algorithm","permalink":"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/enhanced-gpc-algorithm"},"next":{"title":"Code Reference","permalink":"/EGPC-MRI-Segmentation-Docs/docs/category/code-reference"}}');var s=n(4848),o=n(8453);const r={sidebar_position:4,title:"Smart Post-processing"},a="Smart Post-processing Module",l={},c=[{value:"1. Initial Tumor Candidate Identification",id:"1-initial-tumor-candidate-identification",level:2},{value:"2. Adaptive Filtering Based on Location",id:"2-adaptive-filtering-based-on-location",level:2},{value:"3. Configurable Morphological Operations",id:"3-configurable-morphological-operations",level:2},{value:"4. Intelligent Component Analysis",id:"4-intelligent-component-analysis",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"smart-post-processing-module",children:"Smart Post-processing Module"})}),"\n",(0,s.jsx)(t.admonition,{title:"From Raw Clusters to a Clean Mask",type:"tip",children:(0,s.jsxs)(t.p,{children:["The output of the ",(0,s.jsx)(t.a,{href:"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/enhanced-gpc-algorithm",children:"EGPC algorithm"})," is a raw segmentation mask where pixels are assigned to different clusters. However, this raw mask may still contain noise, small artifacts, or non-tumor regions that were incorrectly clustered. The ",(0,s.jsx)(t.code,{children:"smart_postprocess_tumor_segmentation"})," function is a crucial final step that applies a series of intelligent and adaptive filters to refine this mask and produce a clinically plausible result."]})}),"\n",(0,s.jsx)(t.p,{children:"The goal of this module is to eliminate false positives while preserving the true tumor region. This is achieved through a sequence of analytical and morphological operations."}),"\n",(0,s.jsx)(t.h2,{id:"1-initial-tumor-candidate-identification",children:"1. Initial Tumor Candidate Identification"}),"\n",(0,s.jsx)(t.p,{children:"The process begins by assuming that the tumor tissue corresponds to the cluster with the highest average intensity, as tumors often appear hyperintense in FLAIR or T2-weighted MRI scans. The cluster with the maximum centroid value is identified as the initial tumor candidate."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# In smart_postprocess_tumor_segmentation()\r\ntumor_cluster_id = np.argmax(centroids)\r\n\r\ntumor_mask = np.zeros(image_shape, dtype=bool)\r\nbrain_pixel_tumor_labels = (labels == tumor_cluster_id)\r\ntumor_mask[brain_mask] = brain_pixel_tumor_labels\n"})}),"\n",(0,s.jsx)(t.h2,{id:"2-adaptive-filtering-based-on-location",children:"2. Adaptive Filtering Based on Location"}),"\n",(0,s.jsx)(t.p,{children:"A key innovation in our framework is that it does not apply filters blindly. Instead, it first analyzes the properties of the detected regions."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Location Analysis:"})," The function calculates the distance of the detected tumor candidates from the edge of the brain mask using ",(0,s.jsx)(t.code,{children:"ndimage.distance_transform_edt"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Conditional Logic:"})," It uses this information to make smarter decisions. For example, if a detected region is very close to the brain's edge (where artifacts are common), it might be subjected to more aggressive filtering. Conversely, if a filter is predicted to remove a very large portion of a detected region, the algorithm may choose to apply it more gently or skip it entirely. This prevents the accidental removal of a true tumor that happens to be located near the brain's boundary."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Example of adaptive logic\r\nif config['use_adaptive_filtering']:\r\n    # Analyze tumor distance from the brain edge\r\n    min_distance = np.min(tumor_distances)\r\n\r\n    # If tumor is close to the edge, use a gentler filter\r\n    if min_distance < 5:\r\n        edge_filter_distance = max(3, config['edge_filter_distance'] // 3)\r\n    else:\r\n        edge_filter_distance = config['edge_filter_distance']\n"})}),"\n",(0,s.jsx)(t.h2,{id:"3-configurable-morphological-operations",children:"3. Configurable Morphological Operations"}),"\n",(0,s.jsxs)(t.p,{children:["The framework applies a series of standard morphological operations to clean the mask. However, their strength is not fixed; it is configurable through presets (",(0,s.jsx)(t.code,{children:"'weak'"}),", ",(0,s.jsx)(t.code,{children:"'medium'"}),", ",(0,s.jsx)(t.code,{children:"'strong'"}),"). This allows for flexible control over the trade-off between artifact removal and tumor preservation."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"remove_small_objects"}),":"]})," Eliminates small, noisy regions that are unlikely to be clinically significant tumors."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"binary_opening"}),":"]})," Removes thin connections and smooths the contours of the detected regions."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"binary_closing"}),":"]})," Fills small holes inside the detected tumor regions."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"4-intelligent-component-analysis",children:"4. Intelligent Component Analysis"}),"\n",(0,s.jsx)(t.p,{children:"It is common for the initial mask to contain multiple disconnected regions (components). The post-processing module includes logic to handle this intelligently."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["It labels each disconnected region using ",(0,s.jsx)(t.code,{children:"morphology.label"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"It then analyzes the size of each component."}),"\n",(0,s.jsx)(t.li,{children:"If one component is significantly larger than all others (e.g., 5 times larger than the next biggest), the algorithm assumes it is the main tumor body and discards the rest. This is a powerful heuristic for removing smaller, scattered false positives."}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Logic to keep only the dominant tumor component\r\nlabeled_tumors = morphology.label(tumor_mask)\r\nif labeled_tumors.max() > 1:\r\n    # ... logic to calculate component sizes ...\r\n    if size_ratio > 5: // If one component is much larger\r\n        largest_component = np.argmax(component_sizes)\r\n        tumor_mask = (labeled_tumors == largest_component)\n"})}),"\n",(0,s.jsx)(t.p,{children:"By combining these adaptive and analytical steps, the smart post-processing module ensures that the final output mask is not only clean but also clinically and anatomically plausible."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);