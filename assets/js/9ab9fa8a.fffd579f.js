"use strict";(self.webpackChunkgiza_mri=self.webpackChunkgiza_mri||[]).push([[588],{8256:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"code-reference/function-preprocess","title":"Function: preprocess_mri_image","description":"This function serves as the critical first stage of the EGPC pipeline. Its purpose is to take a raw MRI image path as input and produce a clean, normalized image array and a highly accurate binary brain mask. This version implements a more aggressive filtering strategy to robustly handle artifacts.","source":"@site/docs/4-code-reference/2-function-preprocess.md","sourceDirName":"4-code-reference","slug":"/code-reference/function-preprocess","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-preprocess","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/4-code-reference/2-function-preprocess.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Function: preprocess_mri_image"},"sidebar":"tutorialSidebar","previous":{"title":"Code Overview","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/code-overview"},"next":{"title":"Function: run_gpc_for_mri_segmentation","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-gpc-segmentation"}}');var r=i(4848),a=i(8453);const t={sidebar_position:2,title:"Function: preprocess_mri_image"},o="Function: preprocess_mri_image",l={},c=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Values",id:"return-values",level:2},{value:"Core Logic and Pipeline",id:"core-logic-and-pipeline",level:2},{value:"Stage 1: Loading and Initial Enhancement",id:"stage-1-loading-and-initial-enhancement",level:3},{value:"Stage 2: Advanced Brain Extraction and Skull Stripping",id:"stage-2-advanced-brain-extraction-and-skull-stripping",level:3},{value:"Stage 3: Final Mask Application",id:"stage-3-final-mask-application",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsxs)(n.h1,{id:"function-preprocess_mri_image",children:["Function: ",(0,r.jsx)(n.code,{children:"preprocess_mri_image"})]})}),"\n",(0,r.jsx)(n.admonition,{title:"Function Goal",type:"info",children:(0,r.jsx)(n.p,{children:"This function serves as the critical first stage of the EGPC pipeline. Its purpose is to take a raw MRI image path as input and produce a clean, normalized image array and a highly accurate binary brain mask. This version implements a more aggressive filtering strategy to robustly handle artifacts."})}),"\n",(0,r.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def preprocess_mri_image(image_path, skull_strip_threshold=0.1, gaussian_sigma=1.0,\r\n                        enhance_contrast=True, erosion_iterations=5):\n"})}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"image_path"})})," (",(0,r.jsx)(n.code,{children:"str"}),"): The file path to the input MRI scan (e.g., a ",(0,r.jsx)(n.code,{children:".tif"})," file)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"skull_strip_threshold"})})," (",(0,r.jsx)(n.code,{children:"float"}),", optional): The initial intensity threshold for separating the brain from the background. Defaults to ",(0,r.jsx)(n.code,{children:"0.1"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"gaussian_sigma"})})," (",(0,r.jsx)(n.code,{children:"float"}),", optional): The standard deviation for the Gaussian blur filter used for noise reduction. Defaults to ",(0,r.jsx)(n.code,{children:"1.0"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"enhance_contrast"})})," (",(0,r.jsx)(n.code,{children:"bool"}),", optional): A flag to enable or disable contrast enhancement using CLAHE. Defaults to ",(0,r.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"erosion_iterations"})})," (",(0,r.jsx)(n.code,{children:"int"}),", optional): A user-defined value that controls the base strength of the morphological erosion filter. Defaults to ",(0,r.jsx)(n.code,{children:"5"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"return-values",children:"Return Values"}),"\n",(0,r.jsx)(n.p,{children:"The function returns a tuple containing three elements:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"image_array"})})," (",(0,r.jsx)(n.code,{children:"np.ndarray"}),"): A 2D NumPy array representing the final preprocessed image. In this array, all non-brain regions have been masked (set to zero), and the image has been normalized and contrast-enhanced."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"original_image"})})," (",(0,r.jsx)(n.code,{children:"PIL.Image"}),"): The original image loaded from the file path, preserved in its initial state for visualization purposes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"brain_mask_final"})})," (",(0,r.jsx)(n.code,{children:"np.ndarray"}),"): A 2D binary (boolean) NumPy array of the same dimensions as the original image. Pixels with a value of ",(0,r.jsx)(n.code,{children:"True"})," belong to the final, cleaned brain region."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-logic-and-pipeline",children:"Core Logic and Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"The function executes a sequential pipeline designed for robust artifact removal."}),"\n",(0,r.jsx)(n.h3,{id:"stage-1-loading-and-initial-enhancement",children:"Stage 1: Loading and Initial Enhancement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The image is loaded, converted to grayscale (",(0,r.jsx)(n.code,{children:"'L'"})," mode), and its pixel values are normalized to a ",(0,r.jsx)(n.code,{children:"[0.0, 1.0]"})," floating-point range."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"gaussian_sigma > 0"}),", a Gaussian blur is applied to reduce noise."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"enhance_contrast"})," is ",(0,r.jsx)(n.code,{children:"True"}),", Contrast Limited Adaptive Histogram Equalization (CLAHE) is used to improve local contrast, making tissue boundaries more distinct."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stage-2-advanced-brain-extraction-and-skull-stripping",children:"Stage 2: Advanced Brain Extraction and Skull Stripping"}),"\n",(0,r.jsx)(n.p,{children:"This stage creates a highly accurate brain mask through a series of aggressive filtering steps:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initial Masking:"})," A primary ",(0,r.jsx)(n.code,{children:"brain_mask"})," is created using ",(0,r.jsx)(n.code,{children:"skull_strip_threshold"}),". Small noisy components are removed using ",(0,r.jsx)(n.code,{children:"morphology.remove_small_objects"}),", and any holes within the mask are filled with ",(0,r.jsx)(n.code,{children:"ndimage.binary_fill_holes"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Aggressive Erosion:"})," To detach the brain mask from the skull, a strong erosion is applied. The kernel size is dynamically set to ",(0,r.jsx)(n.code,{children:"erosion_iterations + 2"})," to ensure a clean separation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distance-based Skull Remnant Filtering:"})," This is a key step.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It calculates the distance of each pixel from the brain's edge using ",(0,r.jsx)(n.code,{children:"ndimage.distance_transform_edt"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:['It defines a "near-edge" zone with a hardcoded ',(0,r.jsx)(n.code,{children:"edge_threshold"})," of 20 pixels."]}),"\n",(0,r.jsxs)(n.li,{children:["It applies a stricter intensity threshold (",(0,r.jsx)(n.code,{children:"skull_strip_threshold + 0.2"}),") only to this near-edge zone, effectively removing bright skull fragments that often cling to the brain boundary."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strong Morphological Opening:"})," A large opening kernel (",(0,r.jsx)(n.code,{children:"morphology.disk(4)"}),") is used to sever any thin, spurious connections and further smooth the mask's shape."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Component Filtering:"})," ",(0,r.jsx)(n.code,{children:"morphology.label"})," is used to find all disconnected regions, and only the single largest component (the main brain area) is retained."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Final Cleanup:"})," A final, gentle dilation (",(0,r.jsx)(n.code,{children:"recovery_kernel"}),") is applied to reclaim a small amount of tissue lost during erosion, followed by a ",(0,r.jsx)(n.code,{children:"binary_closing"})," to smooth the final mask."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stage-3-final-mask-application",children:"Stage 3: Final Mask Application"}),"\n",(0,r.jsxs)(n.p,{children:["The resulting ",(0,r.jsx)(n.code,{children:"brain_mask_final"})," is multiplied with the enhanced image array to produce the final preprocessed output, where all non-brain information has been removed."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var s=i(6540);const r={},a=s.createContext(r);function t(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);