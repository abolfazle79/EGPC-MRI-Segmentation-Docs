"use strict";(self.webpackChunkgiza_mri=self.webpackChunkgiza_mri||[]).push([[147],{6457:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"code-reference/function-gpc-segmentation","title":"Function: run_gpc_for_mri_segmentation","description":"This function is the heart of the EGPC framework. It takes the preprocessed brain pixels as input and applies our enhanced, adaptive metaheuristic search to find the optimal cluster centroids that best represent the different tissue types in the image.","source":"@site/docs/4-code-reference/3-function-gpc-segmentation.md","sourceDirName":"4-code-reference","slug":"/code-reference/function-gpc-segmentation","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-gpc-segmentation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/4-code-reference/3-function-gpc-segmentation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Function: run_gpc_for_mri_segmentation"},"sidebar":"tutorialSidebar","previous":{"title":"Function: preprocess_mri_image","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-preprocess"},"next":{"title":"Function: postprocess_tumor_segmentation","permalink":"/EGPC-MRI-Segmentation-Docs/docs/code-reference/function-postprocess"}}');var t=n(4848),a=n(8453);const r={sidebar_position:3,title:"Function: run_gpc_for_mri_segmentation"},c="Function: run_gpc_for_mri_segmentation",l={},o=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Values",id:"return-values",level:2},{value:"Core Logic and Pipeline",id:"core-logic-and-pipeline",level:2},{value:"1. Hybrid Initialization",id:"1-hybrid-initialization",level:3},{value:"2. Main Optimization Loop",id:"2-main-optimization-loop",level:3},{value:"3. Final Label Assignment",id:"3-final-label-assignment",level:3}];function h(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsxs)(s.h1,{id:"function-run_gpc_for_mri_segmentation",children:["Function: ",(0,t.jsx)(s.code,{children:"run_gpc_for_mri_segmentation"})]})}),"\n",(0,t.jsx)(s.admonition,{title:"The Optimization Core",type:"tip",children:(0,t.jsx)(s.p,{children:"This function is the heart of the EGPC framework. It takes the preprocessed brain pixels as input and applies our enhanced, adaptive metaheuristic search to find the optimal cluster centroids that best represent the different tissue types in the image."})}),"\n",(0,t.jsx)(s.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"def run_gpc_for_mri_segmentation(image_pixels, n_clusters, max_iter, gpc_params):\n"})}),"\n",(0,t.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"image_pixels"})})," (",(0,t.jsx)(s.code,{children:"np.ndarray"}),"): A 1D NumPy array containing the intensity values of only the brain pixels (output from the preprocessing stage)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"n_clusters"})})," (",(0,t.jsx)(s.code,{children:"int"}),"): The number of clusters (",(0,t.jsx)(s.code,{children:"k"}),") to segment the image into. This is provided by the user."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"max_iter"})})," (",(0,t.jsx)(s.code,{children:"int"}),"): The maximum number of iterations for the GPC algorithm to run. This is also provided by the user."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"gpc_params"})})," (",(0,t.jsx)(s.code,{children:"Structure"}),"): A dictionary-like object containing the core parameters for the GPC algorithm, such as population size (",(0,t.jsx)(s.code,{children:"npop"}),"), gravity (",(0,t.jsx)(s.code,{children:"G"}),"), theta (",(0,t.jsx)(s.code,{children:"Tetha"}),"), etc."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"return-values",children:"Return Values"}),"\n",(0,t.jsx)(s.p,{children:"The function returns a tuple containing two elements:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"final_centroids"})})," (",(0,t.jsx)(s.code,{children:"np.ndarray"}),"): A 1D NumPy array of size ",(0,t.jsx)(s.code,{children:"k"})," containing the final, optimal intensity values for each cluster's center."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"labels"})})," (",(0,t.jsx)(s.code,{children:"np.ndarray"}),"): A 1D NumPy array with the same length as ",(0,t.jsx)(s.code,{children:"image_pixels"}),". Each element contains the integer ID of the cluster to which the corresponding pixel has been assigned."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"core-logic-and-pipeline",children:"Core Logic and Pipeline"}),"\n",(0,t.jsx)(s.p,{children:"The function's logic can be broken down into three major phases:"}),"\n",(0,t.jsx)(s.h3,{id:"1-hybrid-initialization",children:"1. Hybrid Initialization"}),"\n",(0,t.jsxs)(s.p,{children:["To ensure a robust start and avoid early stagnation, the function does not rely on purely random initialization. It uses a ",(0,t.jsx)(s.strong,{children:"multi-strategy approach"}),' to populate the initial set of solutions ("workers"). The population is divided into groups, each initialized with a different strategy: random, quantile-based, histogram-peak-based, and a max-distance method inspired by K-Means++. This maximizes initial diversity.']}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/enhanced-gpc-algorithm#1-hybrid-multi-strategy-initialization",children:"See the theory behind this..."})}),"\n",(0,t.jsx)(s.h3,{id:"2-main-optimization-loop",children:"2. Main Optimization Loop"}),"\n",(0,t.jsxs)(s.p,{children:["This is where the iterative search for the best centroids occurs. The loop runs for ",(0,t.jsx)(s.code,{children:"max_iter"}),' iterations. Inside this loop, for each "worker" in the population, the following steps are performed:']}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Adaptive Parameter Calculation:"})," The substitution probability (",(0,t.jsx)(s.code,{children:"pSS"}),") is dynamically calculated for each iteration to balance exploration and exploitation."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"GPC Movement:"})," The core GPC physics-based equations are used to calculate a new candidate position (a new set of centroids) based on the worker's current position, a random velocity, and random friction."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Stagnation-Aware Acceptance:"})," This is a critical enhancement. The algorithm tracks if the global best solution has improved recently.","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"If a new solution is better, it is always accepted."}),"\n",(0,t.jsxs)(s.li,{children:["If the search is stagnating, the algorithm has a small, decreasing probability of accepting a ",(0,t.jsx)(s.strong,{children:"worse"}),' solution. This allows it to "jump" out of local optima. The probability is calculated using a Simulated Annealing-like formula:',"\n",(0,t.jsx)(s.span,{className:"katex-display",children:(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"P"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mtext,{children:"accept"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mo,{children:"="}),(0,t.jsxs)(s.msup,{children:[(0,t.jsx)(s.mi,{children:"e"}),(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{children:"\u2212"}),(0,t.jsxs)(s.mfrac,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{mathvariant:"normal",children:"\u0394"}),(0,t.jsx)(s.mi,{children:"C"})]}),(0,t.jsx)(s.mi,{children:"T"})]})]})]})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"P(\\text{accept}) = e^{-\\frac{\\Delta C}{T}}"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"P"}),(0,t.jsx)(s.span,{className:"mopen",children:"("}),(0,t.jsx)(s.span,{className:"mord text",children:(0,t.jsx)(s.span,{className:"mord",children:"accept"})}),(0,t.jsx)(s.span,{className:"mclose",children:")"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(s.span,{className:"mrel",children:"="}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1.0235em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord mathnormal",children:"e"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsx)(s.span,{className:"vlist-t",children:(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"1.0235em"},children:(0,t.jsxs)(s.span,{style:{top:"-3.413em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsxs)(s.span,{className:"mord mtight",children:[(0,t.jsx)(s.span,{className:"mord mtight",children:"\u2212"}),(0,t.jsxs)(s.span,{className:"mord mtight",children:[(0,t.jsx)(s.span,{className:"mopen nulldelimiter sizing reset-size3 size6"}),(0,t.jsx)(s.span,{className:"mfrac",children:(0,t.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(s.span,{className:"vlist-r",children:[(0,t.jsxs)(s.span,{className:"vlist",style:{height:"0.8721em"},children:[(0,t.jsxs)(s.span,{style:{top:"-2.656em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size3 size1 mtight",children:(0,t.jsx)(s.span,{className:"mord mtight",children:(0,t.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.13889em"},children:"T"})})})]}),(0,t.jsxs)(s.span,{style:{top:"-3.2255em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(s.span,{className:"frac-line mtight",style:{borderBottomWidth:"0.049em"}})]}),(0,t.jsxs)(s.span,{style:{top:"-3.384em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size3 size1 mtight",children:(0,t.jsxs)(s.span,{className:"mord mtight",children:[(0,t.jsx)(s.span,{className:"mord mtight",children:"\u0394"}),(0,t.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07153em"},children:"C"})]})})]})]}),(0,t.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.344em"},children:(0,t.jsx)(s.span,{})})})]})}),(0,t.jsx)(s.span,{className:"mclose nulldelimiter sizing reset-size3 size6"})]})]})})]})})})})})]})]})]})]})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["As a final failsafe, if an agent is stuck for many iterations, it may be ",(0,t.jsx)(s.strong,{children:"randomly restarted"})," to a new position in the search space."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"/EGPC-MRI-Segmentation-Docs/docs/concepts-and-theory/enhanced-gpc-algorithm#3-stagnation-aware-escape-mechanisms",children:"See the theory behind these enhancements..."})}),"\n",(0,t.jsx)(s.h3,{id:"3-final-label-assignment",children:"3. Final Label Assignment"}),"\n",(0,t.jsxs)(s.p,{children:["After the optimization loop completes, the function takes the best set of centroids found (",(0,t.jsx)(s.code,{children:"pharaohs_agent.position"}),") and performs a final assignment. It calculates the distance of every brain pixel to each of the final centroids and assigns each pixel to the cluster of its nearest centroid. This generates the final ",(0,t.jsx)(s.code,{children:"labels"})," array that is returned."]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var i=n(6540);const t={},a=i.createContext(t);function r(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:s},e.children)}}}]);